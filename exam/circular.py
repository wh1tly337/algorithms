class CircularQueue:
    def __init__(self, k):
        self.k = k  # максимальная вместимость очереди
        self.queue = [None] * k
        self.head = -1  # индекс первого элемента (пустая очередь)
        self.tail = -1  # индекс последнего элемента (пустая очередь)

    def enqueue(self, item):
        """Временная сложность равна O(1)

        В методе enqueue() необходимо рассмотреть три сценария:

        Если круговая очередь переполнена, метод печатает сообщение о том, что
        очередь переполнена. Эта операция проверки и печати сообщения имеет
        временную сложность O(1), поскольку она не зависит от размера очереди.

        Если круговая очередь пуста, метод инициализирует индексы head и tail
        в 0 и назначает элемент на первую позицию в очереди. Эти операции
        являются операциями постоянного времени, не зависящими от размера
        очереди.

        Если в круговой очереди есть свободное место, метод увеличивает индекс
        хвоста, используя (self.tail + 1) % self.k для обеспечения кругового
        движения, и назначает элемент на соответствующую позицию в очереди.
        Опять же, эти операции имеют постоянную временную сложность, поскольку
        они не зависят от размера очереди.

        Поэтому, независимо от количества элементов в очереди, временная
        сложность метода enqueue() остается постоянной, что делает его O(1)."""

        if self.is_full():  # очередь переполнена
            # Есть два варианта как поступать в случае переполнения очереди.
            # Первый:
            print('Очередь переполнена.')
            # Второй: замена элемента головы на новый элемент и сдвиг значений
            # головы (+1) и хвоста (=0) соответственно
        elif self.is_empty():  # добавляем в пустую очередь
            self.head = 0
            self.tail = 0
            self.queue[self.tail] = item
        else:  # добавляем не в пустую очередь
            # Такой расчет нужен для того, чтобы менять значения хвоста при
            # переходе с конца в начало списка, при прохождении его целиком.
            # Без него хвост мог бы быть больше 5, а это невозможно, с ним
            # значения больше 5 превращаются в 0 и все начинается с начала
            self.tail = (self.tail + 1) % self.k
            self.queue[self.tail] = item

    def dequeue(self):
        """Временная сложность равна O(1).

        В методе dequeue() необходимо рассмотреть три сценария:

        Если круговая очередь пуста, метод печатает сообщение о том, что
        очередь пуста. Эта операция проверки и печати сообщения имеет временную
        сложность O(1), поскольку она не зависит от размера очереди.

        Если круговая очередь имеет только один элемент (головной и хвостовой
        индексы равны), метод извлекает элемент из очереди, устанавливает
        головной и хвостовой индексы в -1 (что указывает на пустую очередь) и
        возвращает элемент. Эти операции выполняются за постоянное время и не
        зависят от размера очереди.

        Если круговая очередь имеет более одного элемента, метод извлекает
        элемент из передней части очереди, увеличивает головной индекс с
        помощью (self.head + 1) % self.k, чтобы обеспечить круговую очередь, и
        возвращает элемент. Эти операции также имеют постоянную временную
        сложность, поскольку они не зависят от размера очереди.

        Поэтому, независимо от количества элементов в очереди, временная
        сложность метода dequeue() остается постоянной, что делает его O(1)."""

        if self.is_empty():  # очередь сразу пуста
            return 'Очередь пуста.'
        elif self.head == self.tail:  # очередь будет пуста после удаления
            last_element = self.queue[self.head]
            self.queue[self.head] = None
            self.head = -1  # -1 значение пустой очереди
            self.tail = -1  # -1 значение пустой очереди
            return last_element
        else:  # очередь не пуста и не будет после удаления
            last_element = self.queue[self.head]
            self.queue[self.head] = None
            # Такой расчет нужен для того, чтобы менять значения головы при
            # переходе с конца в начало списка, при прохождении его целиком.
            # Без него голова могла бы быть больше 5, а это невозможно, с ним
            # значения больше 5 превращаются в 0 и все начинается с начала
            self.head = (self.head + 1) % self.k
            return last_element

    def is_full(self):
        """ Временная сложность равна O(1)

        Метод is_full() проверяет, заполнена ли круговая очередь, сравнивая
        увеличенное значение self.tail по модулю self.k с self.head.
        Если увеличенное значение хвоста равно значению головы, это указывает
        на то, что круговая очередь заполнена.

        Вычисления в методе is_full() не зависят от размера круговой очереди,
        поэтому временная сложность остается постоянной независимо от
        количества элементов в очереди. Следовательно, его временная сложность
        равна O(1)."""

        return (self.tail + 1) % self.k == self.head  # O(n*log(n)) из-за %

    def is_empty(self):
        return self.head == -1

    def peek(self):
        if self.is_empty():
            print('Очередь пуста.')
        else:
            return self.queue[self.head]

    def rear(self):
        if self.is_empty():
            print('Очередь пуста.')
        else:
            return self.queue[self.tail]


my_queue = CircularQueue(5)  # Создание экземпляра объемом 5
print('Проверка очередь пустая или нет: ', my_queue.is_empty())

# Добавление элементов в очередь
print('\nДобавление элементов: 10, 20, 30, 40')
my_queue.enqueue(10)
my_queue.enqueue(20)
my_queue.enqueue(30)
my_queue.enqueue(40)
print('Вся очередь: ', my_queue.queue)

# Вывод передних и задних элементов
print('\nПервый:', my_queue.peek())
print('Последний:', my_queue.rear())

# Удаление и вывод этих элементов
print('\nУдаление элементов:')
print(my_queue.dequeue())
print(my_queue.dequeue())
print('Вся очередь: ', my_queue.queue)

# Добавление элементов в очередь
print('\nДобавление элементов: 50, 60')
my_queue.enqueue(50)
my_queue.enqueue(60)
print('Вся очередь: ', my_queue.queue)

# Вывод передних и задних элементов
print('\nПервый:', my_queue.peek())
print('Последний:', my_queue.rear())

# Добавление элементов в очередь
print('\nДобавление элементов: 70')
my_queue.enqueue(70)
my_queue.enqueue(80)
print('Вся очередь: ', my_queue.queue)

# Удаление и вывод этих элементов
print('\nУдаление элементов:')
print(my_queue.dequeue())
print(my_queue.dequeue())
print(my_queue.dequeue())
print('Вся очередь: ', my_queue.queue)

# Удаление и вывод этих элементов
print('\nУдаление элементов:')
print(my_queue.dequeue())
print(my_queue.dequeue())
# Попытка удаления элемента из пустой очереди
print(my_queue.dequeue())
