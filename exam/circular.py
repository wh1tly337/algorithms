class CircularQueue:
    def __init__(self, k):
        self.k = k  # максимальная вместимость очереди
        self.queue = [None] * k
        self.head = -1  # индекс первого элемента
        self.tail = -1  # индекс последнего элемента

    def is_full(self):
        """ Временная сложность равна O(1)

        Метод is_full() проверяет, заполнена ли круговая очередь, сравнивая
        увеличенное значение self.tail по модулю self.k с self.head.
        Если увеличенное значение хвоста равно значению головы, это указывает
        на то, что круговая очередь заполнена.

        Вычисления в методе is_full() не зависят от размера круговой очереди,
        поэтому временная сложность остается постоянной независимо от
        количества элементов в очереди. Следовательно, его временная сложность
        равна O(1)."""

        return (self.tail + 1) % self.k == self.head

    def enqueue(self, item):
        """Временная сложность равна O(1)

        В методе enqueue() необходимо рассмотреть три сценария:

        Если круговая очередь переполнена, метод печатает сообщение о том, что
        очередь переполнена. Эта операция проверки и печати сообщения имеет
        временную сложность O(1), поскольку она не зависит от размера очереди.

        Если круговая очередь пуста, метод инициализирует индексы head и tail
        в 0 и назначает элемент на первую позицию в очереди. Эти операции
        являются операциями постоянного времени, не зависящими от размера
        очереди.

        Если в круговой очереди есть свободное место, метод увеличивает индекс
        хвоста, используя (self.tail + 1) % self.k для обеспечения кругового
        движения, и назначает элемент на соответствующую позицию в очереди.
        Опять же, эти операции имеют постоянную временную сложность, поскольку
        они не зависят от размера очереди.

        Поэтому, независимо от количества элементов в очереди, временная
        сложность метода enqueue() остается постоянной, что делает его O(1)."""

        if self.is_full():
            print('Очередь переполнена.')
        elif self.is_empty():
            self.head = 0
            self.tail = 0
            self.queue[self.tail] = item
        else:
            self.tail = (self.tail + 1) % self.k
            self.queue[self.tail] = item

    def dequeue(self):
        """Временная сложность равна O(1).

        В методе dequeue() необходимо рассмотреть три сценария:

        Если круговая очередь пуста, метод печатает сообщение о том, что
        очередь пуста. Эта операция проверки и печати сообщения имеет временную
        сложность O(1), поскольку она не зависит от размера очереди.

        Если круговая очередь имеет только один элемент (головной и хвостовой
        индексы равны), метод извлекает элемент из очереди, устанавливает
        головной и хвостовой индексы в -1 (что указывает на пустую очередь) и
        возвращает элемент. Эти операции выполняются за постоянное время и не
        зависят от размера очереди.

        Если круговая очередь имеет более одного элемента, метод извлекает
        элемент из передней части очереди, увеличивает головной индекс с
        помощью (self.head + 1) % self.k, чтобы обеспечить круговую очередь, и
        возвращает элемент. Эти операции также имеют постоянную временную
        сложность, поскольку они не зависят от размера очереди.

        Поэтому, независимо от количества элементов в очереди, временная
        сложность метода dequeue() остается постоянной, что делает его O(1)."""

        if self.is_empty():
            print('Очередь пуста.')
        elif self.head == self.tail:
            item = self.queue[self.head]
            self.head = -1
            self.tail = -1
            return item
        else:
            item = self.queue[self.head]
            self.head = (self.head + 1) % self.k
            return item

    def is_empty(self):
        return self.head == -1

    def peek(self):
        if self.is_empty():
            print('Очередь пуста.')
        else:
            return self.queue[self.head]

    def rear(self):
        if self.is_empty():
            print('Очередь пуста.')
        else:
            return self.queue[self.tail]


my_queue = CircularQueue(5)  # Создание экземпляра объемом 5
print('Проверка очередь пустая или нет: ', my_queue.is_empty())

# Добавление элементов в очередь
my_queue.enqueue(10)
my_queue.enqueue(20)
my_queue.enqueue(30)
my_queue.enqueue(40)
print('\nДобавление элементов: 10, 20, 30, 40')
print('Вся очередь: ', my_queue.queue)

# Вывод передних и задних элементов
print('\nПервый:', my_queue.peek())
print('Последний:', my_queue.rear())

# Удаление и вывод этих элементов
print('\nУдаление элементов:')
print(my_queue.dequeue())
print(my_queue.dequeue())
print('Вся очередь: ', my_queue.queue)

# Добавление элементов в очередь
my_queue.enqueue(50)
my_queue.enqueue(60)
print('\nДобавление элементов: 50, 60')
print('Вся очередь: ', my_queue.queue)

# Вывод передних и задних элементов
print('\nПервый:', my_queue.peek())
print('Последний:', my_queue.rear())

# Добавление элементов в очередь
my_queue.enqueue(70)
print('\nДобавление элементов: 70')
print('Вся очередь: ', my_queue.queue)

# Удаление и вывод этих элементов
print('\nУдаление элементов:')
print(my_queue.dequeue())
print(my_queue.dequeue())
print(my_queue.dequeue())
print('Вся очередь: ', my_queue.queue)

# Попытка удаления элемента из пустой очереди
print()
my_queue.dequeue()
