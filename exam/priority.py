import heapq
""" Библиотека heapq в Python - это встроенный модуль, который предоставляет 
функции для работы с кучами. Куча - это специализированная древовидная 
структура данных, удовлетворяющая свойству кучи, которая может быть либо 
min-кучей, либо max-кучей.

Модуль heapq предлагает различные функции для выполнения обычных операций над 
списками, таких как:

*   heappush(heap, item): Эта функция добавляет элемент в кучу, сохраняя 
    свойство кучи. Элемент вставляется в соответствующую позицию в куче.
    heappop(heap): Эта функция удаляет и возвращает наименьший (или наибольший, 
    в зависимости от типа кучи) элемент из кучи. Свойство кучи 
    восстанавливается после удаления.
    
*   heapify(x): Эта функция преобразует список x в допустимую кучу, реорганизуя 
    его элементы так, чтобы они удовлетворяли свойству кучи. Это полезно, когда 
    у вас есть существующий список и вы хотите использовать его в качестве кучи.

*   heapreplace(heap, item): Эта функция вынимает наименьший (или наибольший) 
    элемент из кучи и помещает новый элемент в кучу. Это более эффективно, чем 
    вызов heappop() с последующим heappush().

*   nlargest(k, iterable): Эта функция возвращает k самых больших элементов из 
    итерируемой таблицы в порядке убывания. Для эффективности она использует 
    внутреннюю кучу.

*   nsmallest(k, iterable): Эта функция возвращает k наименьших элементов из 
    итерируемой таблицы в порядке возрастания. Она также использует внутреннюю 
    кучу для повышения эффективности.

Эти функции позволяют легко работать с кучами, выполнять эффективные операции и 
поддерживать свойство кучи. Модуль heapq обычно используется в сценариях, где 
необходимо получить доступ к элементам или удалить их на основе их приоритета 
или порядка."""


class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def enqueue(self, item, priority):
        """ Функция heapq.heappush() в Python имеет временную сложность
        O(log n), где n - количество элементов в куче.

        Функция heappush() используется для вставки элемента в кучу с
        сохранением свойства кучи. Она добавляет элемент в кучу и реорганизует
        кучу, чтобы удовлетворить свойство кучи, которое гарантирует, что
        наименьший элемент всегда находится в корне.

        Временная сложность heappush() определяется процессом реорганизации,
        который включает сравнение добавленного элемента с его родителем и
        потенциальную их замену для поддержания свойства кучи. Этот процесс
        происходит на пути от вставленного элемента к корню, и максимальное
        количество необходимых сравнений равно высоте кучи, которая
        логарифмически равна количеству элементов в куче.

        Поэтому временная сложность heappush() равна O(log n), что делает ее
        эффективной операцией для добавления элементов в кучу."""

        heapq.heappush(self._queue, (priority, self._index, item))
        self._index += 1

    def dequeue(self):
        """ Функция heapq.heappop() в Python имеет временную сложность
        O(log n), где n - количество элементов в куче.

        Функция heappop() используется для удаления и возврата наименьшего
        элемента из кучи с сохранением свойства кучи. Она меняет местами
        корневой элемент (наименьший элемент) с последним элементом в куче,
        удаляет последний элемент и реорганизует кучу, чтобы восстановить
        свойство кучи.


        Процесс реорганизации включает в себя сравнение поменявшегося элемента
        с его дочерними элементами и потенциальную их замену для сохранения
        свойства кучи. Этот процесс происходит по пути от корня к листу, и
        максимальное количество необходимых сравнений равно высоте кучи,
        которая логарифмически равна количеству элементов в куче.

        Поэтому временная сложность heappop() равна O(log n), где n -
        количество элементов в куче. Это делает ее эффективной операцией для
        удаления наименьшего элемента из кучи."""

        if not self.is_empty():
            return heapq.heappop(self._queue)[-1]
        else:
            print('Очередь пуста.')

    def is_empty(self):
        return len(self._queue) == 0

    def peek(self):
        if not self.is_empty():
            return self._queue[0][-1]
        else:
            print('Очередь пуста.')

    def size(self):
        return len(self._queue)

    @property
    def queue(self):
        return self._queue


my_queue = PriorityQueue()  # Создание экземпляра

# Добавление элементов и их приоритета в очередь
my_queue.enqueue("Task 1", 3)
my_queue.enqueue("Task 2", 1)
my_queue.enqueue("Task 3", 2)

print('Проверка очередь пустая или нет: ', my_queue.is_empty())
print('\nВся очередь: ', my_queue.queue)
print('Размер очереди: ', my_queue.size())
print('Первый элемент очереди: ', my_queue.peek())

# Удаление и вывод этих элементов
print('\nУдаление элементов:')
print(my_queue.dequeue())
print(my_queue.dequeue())
print(my_queue.dequeue())

# Попытка удаления элемента из пустой очереди
print()
my_queue.dequeue()
